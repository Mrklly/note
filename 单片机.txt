cpu的结构
存储空间的配置
cpu的运行方式
复位机构
熟悉单片机系统



三极管：箭头朝内 PNP，导通电压顺箭头过，电压导通，电流控制

单片机内部资源：
Flash 程序存储空间  	可重复擦写 容量大 掉电不丢失   EEPROM是狭义的ROM，程序存储空间，掉电不丢失，但是只能访问和修改一个字节，擦除一个字节；
flash分为nor flash和nand flash。
nor flash数据线和地址线分开，可以实现ram一样的随机寻址功能，可以读取任何一个字节。但是擦除仍要按块来擦。


nand flash同样是按块擦除，但是数据线和地址线复用，不能利用地址线随机寻址。读取只能按页来读取。（nandflash按块来擦除，按页来读，norflash没有页）
ARM 数据存储空间 	用来存储程序运行过程中产生的和需要的数据，跟电脑的内存是相似的概念，计算器计算个加减法中间的数据都会保存在RAM里面，关电后数据丢失
SFR 特殊功能寄存器	单片机有很多很多功能，每个功能都会对应一个或多个SFR，通过对SFR的读写来实现单片机的多种多样的功能

扩展：
通常我们说的51单片机，指的都是兼容lntel MCS-51体系架构的一系列单片机，而51是它的一个通俗的简称。
Atmel的AT89C52	NXP(Philips)的P89V51 宏晶科技的STC89C52


选择用宏晶科技的STC89C52：Flash程序空间是8K字节;ARM数据空间是512字节；SFR后面注意留心。================
单片机最小应用系统：指用最少的原件组成单片机可以工作的系统。最小系统的三要素：电源、晶振、复位电路
主流单片机的电源分为5V和3.3V两个标准。
晶振，又叫晶体振荡器，作用：是为单片机系统提供基准时钟信号，单片机内部所有的工作都是以这个时钟信号为步调基准来进行工作的。XTAL1、XTAL2就是两个晶振11.0592M（11059200/s），
外加两个20pF的电容，电容的作用是帮助晶振起振，并维持振荡信号的稳定。
复位电路 复位电路如何起作用我们后边再讲========
	 单片机复位一般是3种情况：上电复位，手动复位，程序自动复位。
上电复位：电源停电重新启动时保证单片机每次都从固定的状态开始工作。
手动复位：程序跑飞或死机，像电脑蓝屏，需要人为按重启按钮，就是手动复位。
自动复位：程序跑飞或死机，单片机往往有一套自动复位机制，像看门狗，具体后面=============，程序长时间失去响应，单片机看门口模式会自动复位重启单片机。还有些情况是我们程序故意重启复位单片机。

有了电源、晶振、复位就可以构成单片机最小系统，可以通过对单片机编程来控制各种各样的外设实现。


初识：
	LED灯（发光二极管）普通的贴片发光二极管。
	工作电压：1.8V-2.2V	工作电流：1mA-20mA
	1mA-5mA	电流越大，肉眼会明显感觉小灯越来越亮。5mA-20mA之间变化时，发光二极管的亮度变化就不是太明显了。超过20mA，LED就会有烧坏的危险。

电容的作用===============

51单片机特殊功能寄存器和位定义
第一条语句：sfr P0 = 0x80;
sfr关键字，是51单片机独有的，作用是定义一个单片机特殊功能寄存器（special function register）。设置P0内部这个模块的8个开关，来让P0这8个IO口输出高电平或低电平。
Keil软件已经把所有这些声明都预先写好并保存到一个专门的文件中去了，我们要用的话只要文件开头添加一行   #include<reg52.h>
第二条语句：sbit LED = P0^0;
这个sbit,就是对刚才所说的SFR里边的8个开关其中的一个进行定义。经过上边第二条语句后，以后只要在程序里写LED，就表示了P0.0口，注意这个P必须大写，也就是我们给P0.0又取了一个更形象的名字叫做LED。

单片机IO 口特殊功能寄存器 P0、P1、P2、P3这4个，每个P口本身又有8个控制端口。这样就确定了单片机一共有32个IO口。（IO，Input，Output，分别是输入和输出）


扩展：Program Size: data=9.0 xdata=0 code=29	编译后的情况：data=9.0,指我们的程序使用了单片机内部的512字节ARM资源中的9个字节，code=29的意思是使用了8K代码Flash资源中的29个字节。



单片机硬件基础知识。
去耦电容的应用。背景是电磁干扰，“静电放电”“快速瞬间群脉冲”“浪涌” ，所有需要电磁兼容，降低干扰。

与外设并联的470uF电容，可以理解成水池子，起到缓冲和稳定的作用，在电压较小的时候将存储的电量释放出来，稳定电压，随后前级电流及时把水缸充满。

扩展：铝电解电容、钽电容、陶瓷电容  电容：通交流隔直流

还与外设并联的0.1uF(100nF),用来滤除高频信号干扰


三极管：根据材料分为硅管和锗管，原理相同，压降略有不同。
三极管有2种：分别是PNP型和NPN型。
有3个极，基极，中间有箭头，一头连接基极b，另外一头连接的是发射极e，剩下的就是集电极c。
牢记：箭头朝内PNP，导通电压顺箭头过，电压导通，电流控制。


三极管在数字电路里的开关特性：一个是控制应用，一个是驱动应用。三极管有截止，放大，饱和三个作用。
IO输出低电平0
如果输出高电平，电流很小，可以加一个三极管（NPN）放大电流。
当IO口并联多个外设时，承受不住负载，可以加一个驱动IC（74HC245）作为缓冲器。只作为电流驱动缓冲，不起到任何逻辑控制的效果。

引脚DIR 是方向引脚。
上拉电阻================
引脚OE 是输出使能，这个引脚上边有一横，表明是低电平有效，当接了低电平后，74HC245就会按照刚才上边说的起到双向缓冲器的作用，如果OE接了高电平，无论DIR怎么接，A和B的引脚是没有关系的。

扩展：C
字符型：unsigned char 	0 - 255
	char	-128 - 127	
整型：	unsigned int	0 - 65535	
	int		-32768 - 32767
长整型:	unsigned long	0 - 4294967295
	long		-2147483648 - 2147483647
浮点型：float		
	double		c51里等同于float

C语言延时方法

	非精确延时：for(i=0; i<100; i++);	i=100;while(i--);

	精确延时：  用定时器定时=======		利用库函数_nop_();========== 

人眼分辨频率高于50Hz时分辨不出。
延时的时间低于20ms，肉眼是分辨不出小灯是在闪烁的。

Keil of Opation:

Target:Xtal(MHz):11.0592	晶振频率,时钟源频率   时钟周期：1/11.0592 s 
C51:Code Optimization 代码优化
level:	0:Constant folding 不变的 不优化
Use Simulator: Use Simulator 使用模拟仿真

比较实用的：
进入 debug 模式，除了可以看程序运行了多长时间外，还可以观察各个寄存器、各个变量的数值变化情
况。点击 View 菜单里的 Watch Windows-->Watch 1，可以打开变量观察窗口

count（cnt）计数


#include<reg52.h>
sbit LED = P0^0;
sbit ADDR0 = P1^0;
sbit ADDR1 = P1^1;
sbit ADDR2 = P1^2;
sbit ADDR3 = P1^3;
sbit ENLED = P1^4;

void main()
{
	unsigned int i = 0;
	unsigned int cnt = 0;
	ADDR0 = 0;
	ADDR1	= 1;
	ADDR2 = 1;
	ADDR3 = 1;
	ENLED =	0;
	
	while(1)
	{
//		LED = 0;
//		for(i = 0;i < 30000; i++);
//		LED = 1;
//		for(i = 0;i < 30000; i++);
		P0 = ~(0x01<<cnt);
		for(i = 0;i < 20000; i++);
		cnt++;
		if(cnt >= 8)
		{
			cnt = 0;
		}
	}
}

A^B 按位异或 


时钟周期：1/11.0592
机器周期：标准51单片机机器周期是12个时钟周期。

定时器和计数器是单片机内部的同一个模块，通过配置SFR（特殊功能寄存器）可以实现两种不同的功能。
定时器就是用来定时的。定时器内部有个寄存器，寄存器的值每经过一个机器周期就会自动加1，我们可以把机器周期理解为定时器的计数周期。

12/11052900 s，计数器加1。
钟表加到60后，秒自动变成0。这种是溢出的。
定时器的多种工作模式====================分别使用不同的位宽（指使用多少个二进制位），假如使用16位的定时器，就是2个字节，最大值就是65535，加到65535后，再加1就算溢出。然后这个值变成0。

TCON 标注了“可位寻址”，而TMOD 标注了“不可位寻址”。意思就是说：比如TCON有一个位叫TR1,可以在程序中直接TR1 = 1这样的操作。但TMOD里的位就不能这样操作。必须一次操作这整个字节，一次性对TMOD所有位操作。=========


数码管分为共阳极和共阴极两种。共阴数码管就是8只LED小灯的阴极是连接在一起的，阴极是公共端，由阳极来控制单个小灯的亮灭。   边上2个com,把公共电流平均到2个引脚上去，降低单条线路承受的电流。
通过控制数码管中8个LED小灯来实现显示数字的效果。这一个字节8位形成一个真值表。每一个数值对应一个16进制数。
真值表：
字符 0 1 2 3 4 5 6 7
数值 0xC0 0xF9 0xA4 0xB0 0x99 0x92 0x82 0xF8
字符 8 9 A B C D E F
数值 0x80 0x90 0x88 0x83 0xC6 0xA1 0x86 0x8E
51单片机的关键字code。unsigned char or unsigned int 放在RAM中，在加了code关键字后数据放在Flash中，这样可以降低RAM的消耗。


#include <reg52.h>
sbit ADDR0 = P1^0;
sbit ADDR1 = P1^1;
sbit ADDR2 = P1^2;
sbit ADDR3 = P1^3;
sbit ENLED = P1^4;
//用数组来存储数码管的真值表，数组将在下一章详细介绍
unsigned char code LedChar[] = {
0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
};
void main(){
unsigned char cnt = 0; //记录 T0 中断次数
unsigned char sec = 0; //记录经过的秒数
ENLED = 0; //使能 U3，选择数码管 DS1
ADDR3 = 1;
ADDR2 = 0;
ADDR1 = 0;
ADDR0 = 0;
TMOD = 0x01; //设置 T0 为模式1
第 5 章 5. 单片机定时器与数码管基础 | 104
TH0 = 0xB8; //为 T0 赋初值 0xB800
TL0 = 0x00;
TR0 = 1; //启动 T0
while (1){
if (TF0 == 1){ //判断 T0 是否溢出
TF0 = 0; //T0 溢出后，清零中断标志
TH0 = 0xB8; //并重新赋初值
TL0 = 0x00;
cnt++; //计数值自加1
if (cnt >= 50){ //判断 T0 溢出是否达到50次
cnt = 0; //达到50次后计数值清零
P0 = LedChar[sec]; //当前秒数对应的真值表中的值送到 P0 口
sec++; //秒数记录自加1
if (sec >= 16){ //当秒数超过 0x0F(15)后，重新从0开始
sec = 0;
}
}
}
}
}

if()
{
}else if()
{
}

switch(cnt)
{
case i:  ;break;
case i:	 ;break;
default: ;break;
}

数码管消除“鬼影”，数码管不应该亮的段，似乎有微微的发亮。===== 关闭段和关闭位。

标准51单片机中控制中断的寄存器有两个，一个是中断使能寄存器，另一个是中断优先级寄存器。
中断使能寄存器：0xA8 可位寻址
位 符号 描述
7 EA 总中断使能位，相当于总开关
6 -- --
5 ET2 定时器2中断使能
4 ES 串口中断使能
3 ET1 定时器1中断使能
2 EX1 外部中断1使能
1 ET0 定时器0中断使能
0 EX0 外部中断0使能

EA = 1，打开中断总开关，然后用到哪个分中断，再打开相应的控制位就可以。

void InterruptTimer0() interrupt 1{｝中断服务函数
Interrupt（中断） 关键字，一定不能错，这是中断特有的关键字。另外后边还有一个数字1，这个数字1  interrupt 后面中断函数编号
的数字 x 就是根据中断向量得出的，它的计算方法是 x*8+3=向量地址 1就是中断函数编号。
中断函数编号 中断名称 中断标志位 中断使能位 中断向量地址 默认优先级
0 外部中断0 IE0 EX0 0x0003 1(最高)
1 T0 中断 TF0 ET0 0x000B 2
2 外部中断1 IE1 EX1 0x0013 3
3 T1 中断 TF1 ET1 0x001B 4
4 UART 中断 TI/RI ES 0x0023 5
5 T2 中断 TF2/EXF2 ET2 0x002B 6      

中断优先级有两种，一种是抢占优先级，一种是固有优先级。

表6-4 IP――中断优先级寄存器的位分配（地址 0xB8、可位寻址）
位 7 6 5 4 3 2 1 0
符号 -- -- PT2 PS PT1 PX1 PT0 PX0
复位值 -- -- 0 0 0 0 0 0

表6-5 IP――中断优先级寄存器的位描述
位 符号 描述
7 -- 保留
6 -- 保留
5 PT2 定时器2中断优先级控制位
4 PS 串口中断优先级控制位
3 PT1 定时器1中断优先级控制位
2 PX1 外部中断1中断优先级控制位
1 PT0 定时器0中断优先级控制位
0 PX0 外部中断0中断优先级控制位

抢占优先级：谁的优先级高，谁就可以马上去执行
固有优先级：数字越小优先级越高，与抢占优先级不同点就是不具有抢占的特性


C语言：变量的作用域和存储类别
局部变量只在本函数内有效。
全局变量在函数外声明的变量就是全局变量。
编程规范：
一个程序文件内所有的全局变量都应该定义在文件的开头部分，在文件中所有函数之前。
尽量减少全局变量的使用，能用局部变量代替的就不用全局变量。
在同一源文件中，全局变量和局部变量同名，在局部变量作用域范围内，只有局部变量有效，全局变量不起作用，就是局部变量具有更高的优先级。从编程规范上讲，避免全局变量与局部变量重名，从而避免不必要的误解和误操作。

变量的存储类别分别为自动、静态、寄存器和外部这四种。
局部变量中，不加static这个关键字来修饰，都属于自动变量，也叫动态存储变量。自动分配存储空间，自动释放存储空间。自动变量可以用auto这个关键字修饰，但也可以省略。
全局变量都是静态变量，加了static这个关键字修饰的局部变量称为静态局部变量。全局变量它的特点是：在整个生存期中只赋一次初值，在第一次执行该函数时，它的值就是给定的那个初值，而之后在该函数所有的执行次数中，它的值都是上一次函数执行结束后的值，即它可以保持前次的执行结果。
静态局部变量它的特点是：某个变量只在一个函数中使用，但我们却想在函数多次调用期间保持住这个变量的值而不丢失。这时就可以使用静态局部变量。如果去掉static这个关键字，那么每次进入中断函数后，i都会被初始化成0,这样就没有保存到上一次的结果，与我们想要的结果相悖。

单片机最小的系统（电源、晶振、复位电路）
晶振  分为无源晶振和有源晶振  无源晶振称为crystail(晶体)，有源晶振称为oscillator(振荡器)
有源晶振是一个完整的谐振振荡器，利用石英晶体的压电效应来供电，要供电，不需要外接其它器件，主动产生振荡频率，可以提供高精度的频率基准，信号质量也比无源信号好。
无源晶振自身无法振荡起来，需要和芯片内部的振荡电路一起工作才能振荡，允许不同电压，信号质量和精度较有源的晶振差一些。无源晶振两侧通常有个电容，容值在10pF - 40pF之间，具体大小要根据要求来选，没有就用20pF。
有源晶振有4个引脚：VCC,GND,晶振输出引脚，没有用到的悬空引脚。
无源晶振有2个或3个引脚：3个的话中间引脚是晶振的外壳接GND，两侧就是晶振的2个引出脚，这两个引脚作用是等同的，就像是电阻的2个引脚一样没有正负之分。对于无源晶振，用我们的单片机上的两个晶振引脚接上去即可，而有源晶振，只接到单片机晶振的输入引脚 有源晶振的输出引脚上，单片机的输出引脚上不需要接。

单片机复位电路
这个电路处于稳态时，电容起到隔离直流的作用，隔离了+5V,复位按键是弹起状态，下边电路没有电压差，所以按键和电容C11以下部分都是和GND相等的，也就是0v。
上电瞬间，电容C11上方电压是5V，下方是0V，电容充电正离子从上往下充电，负离子从下往上充电，这个时候就是一根导线，有了电压差，接通电流，进行复位启动状态。电容充满，电流消失，RST和GND的电位没有压差，复位电路完成工作。
单片机通常值是0.7VCC，时间t=1.2 RC,R=4700欧姆，C是0.1uF，t=0.000564秒，即564us。按下按键的瞬间，电容两端的5V电压会被直接接通，此刻会有一个瞬间的大电流冲击，会在局部范围产生电磁干扰，在电容放电回路中串入一个18欧的电阻来限流。


独立按键和矩阵按键

三极管，不管PNP还是NPN，只要箭头的始端比末端低电压就可以导通三极管的e极和c极。

485芯片:__
	RE 为0时，485芯片RO输出；DE为1时，DI输入；
	
	
8个bit位是0~255
16个bit位是0~65535

8<<2 = 32 8左移2位 8*4=32
对于左移，直观的理解为，对于正数来说，左移1位相当于乘以2（但效率比乘法高）；对于负数来说，没有直观的理解
16>>2 = 4  16右移2位 16/4=4
对于右移，直观的理解为，对于正数来说，右移1位相当于除以2（但效率比除法高）；对于负数来说，没有直观的理解。

Thumb指令集是Arm指令集的一个子集，它具有16位的代码宽度

AHB，是Advanced High performance Bus的缩写，译作高级高性能总线，这是一种“系统总线”。

AHB主要用于高性能模块(如CPU、DMA和DSP等)之间的连接。AHB 系统由主模块、从模块和基础结构(Infrastructure)3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。APB，是Advanced
Peripheral Bus的缩写，这是一种外围总线。

APB主要用于低带宽的周边外设之间的连接，例如UART、1284等，它的总线架构不像 AHB支持多个主模块，在APB里面唯一的主模块就是APB 桥。再往下，APB2负责AD，I/O，高级TIM，串口1；APB1负责DA，USB，SPI，I2C，CAN，串口2345，普通TIM。

你做一个结构体 有任务编号和执行函数，
放到一个数组里面，看到编号就执行对应的函数就好了

High performance Bus Clock 高级高性能总线时钟(HCLK)
Peripheral Bus Clock 外围设备总线时钟(PCLK)
Free Runing Clock 自由运行时钟（FCLK）

typedef struct??
{
? ? ? ? uint8_t task_id;
? ? ? ? void(*task_func_ptr)(void *data);
}task_t;


void task1_func(void *data)
{
? ? ? ? //do something
}

void task2_func(void *data)
{
? ? ? ? //do something
}

void task3_func(void *data)
{
? ? ? ? //do something
}

void task4_func(void *data)
{
? ? ? ? //do something
}

void task5_func(void *data)
{
? ? ? ? //do something
}

task_t task_list[5] = {
? ? ? ? ? ? ? ? { 1, task1_func },
? ? ? ? ? ? ? ? { 2, task2_func },
? ? ? ? ? ? ? ? { 3, task3_func },
? ? ? ? ? ? ? ? { 4, task4_func },
? ? ? ? ? ? ? ? { 5, task5_func }
};

task_t *pTask = &task_list[0];

int main(void)
{
? ? ? ? int data;
? ? ? ? uint8_t cmd_group[10]; //
? ? ? ? uint8_t i, cmd;

? ? ? ? while (1)
? ? ? ? {
? ? ? ? ? ? ? ? //从上位机获取命令组
? ? ? ? ? ? ? ? receive_cmd_from_pc(cmd_group);

? ? ? ? ? ? ? ? for (i = 0; i < 10; i++)
? ? ? ? ? ? ? ? {
? ? ? ? ? ? ? ? ? ? ? ? //获取单个小任务对应的命令
? ? ? ? ? ? ? ? ? ? ? ? cmd = cmd_group[i];
? ? ? ? ? ? ? ? ? ? ? ? //执行该命令对应的小任务
? ? ? ? ? ? ? ? ? ? ? ? (pTask + cmd)->task_func_ptr(&data);
? ? ? ? ? ? ? ? }
? ? ? ? }

? ? ? ? return 0;
}




